---
layout: presentation
title: "Real World Dotty"
date: "2017-09-20"
---

<section>
    <h3>Dotty's new REPL</h3>
    <h1>Real World Dotty</h1>
    <h3>Felix Mulder</p>
</section>

<section>
    <h2>In This Talk</h2>
    <ul>
        <li class="fragment highlight-blue" data-fragment-index="1">Building a REPL 101</li>
        <li class="fragment highlight-blue" data-fragment-index="1">The New REPL</li>
        <li>New Language Features</li>
    </ul>
</section>

<section>
    <h2>After this take you'll know</h2>
    <ul>
        <li class="fragment">How to build a REPL</li>
        <li class="fragment">About features in Scala 3</li>
    </ul>
</section>

<section>
    <span style="text-transform: uppercase">
        Slides: <a href="http://felixmulder.com">felixmulder.com</a>
    </span>
</section>

<section>
    <h1>Questions up front</h1>

    <aside class="notes">
        <ul>
            <li>The best time to ask a question is when you have one</li>
        </ul>
    </aside>
</section>

<section>
    <img class="no-bg" src="epfl.svg" width="250"/>

    <aside class="notes">
        <ul>
            <li>Compiler engineer & release manager</li>
            <li>Big picture</li>
            <li>Pull in the same dir</li>
            <li>Get us on to a release schedule</li>
        </ul>
    </aside>
</section>

<section>
    <img class="no-bg" src="klarna.svg" width="250"/>
</section>

<section>
    <h2>Repo Activity</h2>
    <img class="border" src="./contribs.png">
    <h3>88 Contributors</h3>

    <aside class="notes">
        <ul>
            <li>Making it easy for people to contrib</li>
            <li>Proper tags, guides for certain parts, better docs</li>
            <li>Up from a dussin contributors</li>
        </ul>
    </aside>
</section>

<section>
    <h2>So, how do you build a REPL?</h2>
</section>

<section>
    <h2>Evaluate expressions <span class="fragment fade-out">& Commands</span></h2>
</section>

<section>
    <pre><code class="scala">Expression => Result</code></pre>
</section>

<section>
    <pre><code class="scala">IO[String] => Result[String]</code></pre>

    <aside class="notes">
        <ul>
            <li>Try to keep this as pure as possible</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala">type Result[T] = ???</code></pre>

    <aside class="notes">
        <ul>
            <li>Decide upon a datastructure for Res[T]</li>
            <li>How do we capture failure in a compiler?</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Compiler Crash-Course</h2>
    <ol>
        <li class="fragment">Tokenize</li>
        <li class="fragment">Parse AST</li>
        <li class="fragment">Typecheck</li>
        <li class="fragment">...</li>
        <li class="fragment">Runnable</li>
    </ol>

    <aside class="notes">
        <ul>
            <li>AST represented as ADT</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala">type Result[T] = ValidatedNel[ErrorMessage, T]</code></pre>
</section>

<section>
    <img class="border" src="./external-deps.jpg">
    <p style="font-size: small">*that aren't Java</p>

    <aside class="notes">
        <ul>
            <li>Binary compat, but most importantly - bootstrap</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Dotty has union types! üí°</h2>
    <pre class="fragment clear"><code class="scala">type Result[T] = List[ErrorMessage] | T </code></pre>

    <aside class="notes">
        <ul>
            <li>Unboxed Either</li>
        </ul>
    </aside>
</section>

<section>
    <h2>A Compromise</h2>
    <pre><code class="scala">type Result[T] = scala.util.Either[List[ErrorMessage], T]</code></pre>
</section>

<section>
    <pre><code class="scala">val readLine: IO[String] = IO { "val x = 5" }

<span class="fragment">def interpret(input: String): Result[String] = ...</span>
    </code></pre>
    <aside class="notes">
        This will be what we're trying to evaluate.
    </aside>
</section>

<section>
    <pre><code class="scala">

val pipeline: IO[String] = for {
  input  <- readLine
  result =  interpret(input).fold(reportErrors, reportResult)
} yield result

pipeline.unsafeRunSync() // "val x: String = 5"</code></pre>
</section>

<section>
    <pre><code class="scala">def interpret(input: String): Result[String] =
  <span class="fragment" data-fragment-index="1">compile(input).flatMap(evaluate)</span>

<span class="fragment" data-fragment-index="2">def compile(input: String): Result[tpd.Tree] =
  for {
    <span class="fragment" data-fragment-index="3">exprs     <- parse(input)</span>
    <span class="fragment" data-fragment-index="4"><span class="fragment highlight-blue" data-fragment-index="8">contained <- wrap(exprs)</span></span>
    <span class="fragment" data-fragment-index="5">typed     <- compile(contained)</span>
  } <span class="fragment" data-fragment-index="6">yield typed</span>
</span>
<span class="fragment" data-fragment-index="7">def evaluate(tree: tpd.Tree): Result[String] = ...</span></code></pre>

    <aside class="notes">
        <ul>
            <li>Interpreting is simply compiling and evaluating</li>
            <li>Similar to scalac && scala</li>
            <li>Think back to our pipeline</li>
            <li>Then we have some evaluation function, to care about later</li>
            <li>The first non-obvious thing here is the `wrap`</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Why wrap things?</h2>
    <h3 class="fragment">Need to run the full compiler pipeline</h3>

    <aside class="notes">
        <ul>
            <li>Can typecheck expression with frontend</lI>
            <li>Has to be valid scala to be emitted by backend</li>
        </ul>
    </aside>
</section>

<section>
    <h2>What should we be compiling?</h2>
    <pre><code class="scala">scala> val x = 5

<span class="fragment">// =>

object rs$l1 {
  val x = 5
}</span></code></pre>
</section>

<section>
    <h2>What should we be compiling?</h2>
    <pre><code class="scala">scala> 5

<span class="fragment">// =>

object rs$l2 {
  val res0 = 5
}</span></code></pre>
</section>

<section>
    <h2>What should we be compiling?</h2>
    <pre><code class="scala">scala> class Foo

<span class="fragment">// =>

object rs$l3 {
  class Foo
}</span></code></pre>
</section>

<section>
    <h2>Is that it?</h2>
    <pre class="fragment clear" data-fragment-index="1"><code class="scala">scala> val y = x

<span class="fragment" data-fragment-index="2">// =>

object rs$l4 {
  <span class="fragment" data-fragment-index="3">import rs$l1._</span>
  val y = x <span class="fragment fade-out" data-fragment-index="3">// error: not found: value x</span>
}</span></code></pre>
</section>

<section>
    <h2>Is that it?</h2>
    <pre><code class="scala">val y = x

// =>

object rs$l4 {
  import rs$l1._, rs$l2._, rs$l3._
  val y = x                             
}</code></pre>
</section>

<section>
    <h2>What about implicits?</h2>
    <pre><code class="scala"><span class="fragment">scala> implicit val x: String = "wrong"</span>
<span class="fragment">scala> implicit val y: String = "right"</span>
<span class="fragment">scala> implicitly[String]</span>
<span class="fragment">
// =>

object rs$l1 { implicit val x: String = "wrong" }

<span class="fragment">object rs$l2 {
  import rs$l1._
  implicit val y: String = "right"
}</span>

<span class="fragment">object rs$l3 {
  import rs$l1._, rs$l2._
  val res0 = implicitly[String] // error: ambiguous implicit values
}</span>
</span></code></pre>
<span class="fragment">üôà</span>
</section>

<section>
    <h2>Dotty's Concept of Context</h2>
    <ul class="fragment">
        <li><code>Context</code> is analogous to scalac's <code>Global</code></li>
        <li>Local</li>
        <li>Scope</li>
        <li>Owner</li>
        <li>Settings</li>
        <li>Immutable</li>
    </ul>
</section>

<section>
    <pre><code class="scala">package example

class A

class B {
                                                 
 def f = ???
 def g = ???
}

</code></pre>
</section>

<section>
    <pre><code class="scala">package example {
  <span class="fragment">// Context(owner = example, scope = Scope(A, B))</span>
  class A

  class B {
   <span class="fragment">// Context(owner = B, scope = Scope(A, B, f, g))</span>
   def f = ???
   def g = ???
  }
}
</code></pre>
</section>

<section>
<pre><code class="scala">
object rs$l1 { implicit val x: String = "wrong" }

object rs$l2 {
  <span class="fragment" data-fragment-index="1">// Context(owner = rs$l2, scope = ShadowScope(rs$l1._))</span>
  <span class="fragment fade-out" data-fragment-index="1">import rs$l1._</span>
  implicit val y: String = "right"
}

object rs$l3 {
  <span class="fragment" data-fragment-index="2">// Context(owner = rs$l2, scope = ShadowScope(rs$l2._, rs$l1._))</span>
  <span class="fragment fade-out" data-fragment-index="2">import rs$l1._, rs$l2._</span>
  val res0 = implicitly[String] <span class="fragment" data-fragment-index="2">// val res0: String = "right" üòÅüëç</span>
}
</code></pre>
    <aside class="notes">
        <ul>
            <li>When typechecking, we can do so in the context of something</li>
            <li>Could manipulate the context to make it seem like we have imports or don't</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala">def compile(input: String): Result[tpd.Tree] =
  for {
    exprs     <- parse(input)
    contained <- wrap(exprs)
    typed     <- compile(contained)
  } yield typed
</code></pre>
</section>

<section>
    <pre><code class="scala">def compile(tree: untpd.Tree)<span class="fragment">(implicit ctx: Context)</span>: tpd.Tree = {

  <span class="fragment">def addMagicImports(initCtx: Context): Context =
    (initCtx /: lineNumbers) { (ctx, line) =>
      ctx.setNewScope.setImportInfo(importRef(line))
    }</span>

  // Use dotty internals to compile the `tree` => then
  // return the typed version of it
}</code></pre>
</section>

<section>
    <pre><code class="scala">def interpret(input: String): Result[String] =
  compile(input).flatMap(<span class="fragment highlight-blue">evaluate</span>)

<span class="fragment">def evaluate(tree: tpd.Tree): Result[String] = {
  <span class="fragment">// 1. Render definitions: class, trait, object, type, def</span>
  <span class="fragment">// 2. Render values: val, var</span>
}</span></code></pre>
</section>

<section>
    <pre><code class="scala">def evaluate(tree: tpd.Tree): Result[String] = {
  val defs = ctx.atPhase(ctx.typerPhase.next) {
    tree.symbol
      .find(isWrapper).toList
      .flatMap(collectDefs)
      .map(renderDefs)
  }

  val values = <span class="fragment highlight-blue">renderValues(tree)</span>

  // Return everything separated by newlines:
  (defs ++ values).mkString("\n")
}</code></pre>
</section>

<section>
    <h2>What does Haskell do?</h2>
    <h3 class="fragment">Interpreter</h3>

    <aside class="notes">
        <ul>
            <li>
                When you find yourself implementing something like this - ask
                yourself, what does haskell do
            </li>
        </ul>
    </aside>
</section>

<section>
    <blockquote class="fragment">"Let's just use Reflection" - Java devs</blockquote>
</section>

<section>
    <pre><code class="scala">def renderValues(tree: tpd.Tree): List[String] = {
  def valueOf(sym: Symbol): Option[String] = { ...  }

  collectValues(tree).map { symbol =>
    val dcl = symbol.showUser
    val res = if (symbol.is(Lazy)) Some("&lt;lazy&gt;") else valueOf(symbol)

    res.map(value => show"$dcl = $value")
  }
}
</code></pre>
</section>

<section>
    <pre><code class="scala">def valueOf(sym: Symbol): Option[String] = {
  val wrapperName = sym.owner.name
  val wrapper = Class.forName(wrapperName, true, classLoader)

  val res =
    wrapper
      .getDeclaredMethods.find(_.getName == sym.name + "Show")
      .map(_.invoke(null).toString)

  if (!sym.is(Flags.Method) && sym.info == defn.UnitType)
    None
  else res
}</code></pre>
</section>

<section>
    <pre><code class="scala">trait Show[-T] {
  def show(t: T): String
}
</code></pre>
</section>

<section>
    <h2>What should we be compiling?</h2>
    <pre><code class="scala">scala> val x = 5

<span class="fragment">// =>

object rs$l1 {
  val x = 5
  <span class="fragment">def xShow = x.show</span>
}</span></code></pre>

    <p><span class="fragment">Trivia - why a <code>def</code>?</span></p>
</section>

<section>
    <pre><code class="scala">def valueOf(sym: Symbol): Option[String] = {
  val wrapperName = sym.owner.name
  val wrapper = Class.forName(wrapperName, true, classLoader)

  val res =
    wrapper
      .getDeclaredMethods.find(_.getName == sym.name + "Show")
      .map(_.invoke(null).toString) <span class="fragment">// Initializes the object üôä</span>

  if (!sym.is(Flags.Method) && sym.info == defn.UnitType)
    None
  else res
}</code></pre>
</section>

<section>
    <pre><code class="scala">Expression => Result</code></pre>
    <br/>
    <pre class="fragment"><code>üé© + üêø == `Ship it!`</code></pre>
</section>

<section>
    <h2>New Language Features</h2>
    <h3>And how they were (mis-)used in this project</h3>
</section>

<section>
    <h2>Dotty has union types! üí°</h2>
    <pre><code class="scala">type Result[T] = List[ErrorMessage] | T </code></pre>
</section>

<section>
    <pre><code class="scala">type Result[T] = List[ErrorMessage] | T

implicit class ResultOps[A](res: Result[A]) extends AnyVal {
  def flatMap[B](f: A => Result[B]): Result[B] = res match {
    case err: List[ErrorMessage] => err <span class="fragment" data-fragment-index="1">// warning: type erasure</span>
    case a: A => f(a)                   <span class="fragment" data-fragment-index="1">// warning: match on generic type</span>
  }
}</code></pre>
</section>

<section>
    <pre><code class="scala">type Result[T] = Errors | T
private case class Errors(values: List[ErrorMessage])

implicit class ResultOps[A](res: Result[A]) extends AnyVal {
  def flatMap[B](f: A => Result[B]): Result[B] = res match {
    case err: Errors => err
    case a: A @unchecked => f(a)
  }

  ...
}</code></pre>
</section>

<section>
    <pre><code class="scala">for { x <- 1 } yield 1</code></pre>
    <p class="fragment">üôà</p>
    <pre class="fragment clear"><code class="scala">1 <:< Result[T]</code></pre><br/>
    <pre class="fragment clear"><code class="scala">1 <:< (Errors | T)</code></pre><br/>
    <pre class="fragment clear"><code class="scala">(1 <:< Errors) || (1 <:< T)</code></pre><br/>
    <pre class="fragment clear"><code class="scala">false || (1 <:< T)</code></pre><br/>
    <pre class="fragment clear"><code class="scala">true</code></pre>
</section>

<section>
    <h2>When not to use a union type</h2>
    <ul>
        <li>Instead of <code>Either</code></li>
        <li>Instead of <code>Coproduct</code></li>
        <li>When part of the union is generic</li>
    </ul>
</section>

<section>
    <h2>When to use union types</h2>
    <ul>
        <li class="fragment highlight-blue">Anonymous ADTs</li>
        <li>Unordered disjunctions</li>
        <li>Value Enumerations</li>
        <li>Dynamic Language Interop</li>
    </ul>
</section>

<section>
    <pre><code class="scala">
enum Message {
  case PlainMessage[A](value: A)
  case ComputableMessage[A](value: () => A)
  case NoMessage
}

type SomeMessage[A] = PlainMessage[A] | ComputableMessage[A]

<span class="fragment">def log[A : Broker](msg: SomeMessage): IO[Unit] =
  msg match {
    case msg: PlainMessage      => IO { println(msg) }
    case msg: ComputableMessage => IO { println(msg.compute) }
  }</span></code></pre>
</section>

<section>
    <h2>When to use union types</h2>
    <ul>
        <li>Anonymous ADTs</li>
        <li class="fragment highlight-blue">Unordered disjunctions</li>
        <li>Value Enumerations</li>
        <li>Dynamic Language Interop</li>
    </ul>
</section>

<section>
    <pre><code class="scala"><span class="fragment" data-fragment-index="1">(</span>String | Int<span class="fragment" data-fragment-index="1">) =:= (Int | String)</span></pre></code>
</section>

<section>
    <h2>When to use union types</h2>
    <ul>
        <li>Anonymous ADTs</li>
        <li>Unordered disjunctions</li>
        <li class="fragment highlight-blue">Value Enumerations</li>
        <li>Dynamic Language Interop</li>
    </ul>
</section>

<section>
    <pre><code class="scala">enum Days {
  case Monday
  case Tuesday
  case Wednesday
  case Thursday
  case Friday
  case Saturday
  case Sunday
}

type Weekday = Monday.type   | Tuesday.type | ... | Friday.type
type Weekend = Saturday.type | Sunday.type
    </pre></code>
</section>

<section>
    <h2>Sadly</h2>
    <div class="fragment">
        <h3>Allow singleton types in union types</h3>
        <a href="https://github.com/lampepfl/dotty/issues/1551">#1551</a>
    </div>
</section>

<section>
    <h2>When to use union types</h2>
    <ul>
        <li>Anonymous ADTs</li>
        <li>Unordered disjunctions</li>
        <li>Value Enumerations</li>
        <li class="fragment highlight-blue">Dynamic Language Interop</li>
    </ul>
</section>

<section>
    <pre><code class="scala">type UndefOr[A] = A | Unit</pre></code>
</section>

<section>
    <h2>Improved Type Inference</h2>
    <pre><code class="scala">val res: Either[Exception, Int] = Right(1)

<span class="fragment">res.map(_ + 1)</span>
    </pre></code>
</section>

<section>
    <h2>Improved Type Inference</h2>
    <pre><code class="scala">val res: Either[Exception, (Int, String)] = Right((1, "foo"))

<span class="fragment">res.map((i, str) => (i + 1, str + "bar"))</span>
<span class="fragment">// error: found (Int, String) => (Int, String),
//        required ((Int, String)) => ?</span>

<span class="fragment">res.map { case (i, str) => (i + 1, str + "bar") }</span>
    </pre></code>

    <aside class="notes">
        Adapting by auto-tupling
    </aside>
</section>

<section>
    <pre><code class="scala">implicit class ListOps[A](val xs: List[A]) extends AnyVal {
  def myFoldLeft1[B](init: B, f: (B, A) => B): B = ...

  <span class="fragment" data-fragment-index="4">def myFoldLeft2[B](init: B)(f: (B, A) => B): B = ...</span>
}

<span class="fragment" data-fragment-index="5">List(1, 2, 3).myFoldLeft2(0)(_ + _)</span>
<span class="fragment fade-out" data-fragment-index="4"><span class="fragment" data-fragment-index="1">List(1, 2, 3).myFoldLeft1(0, _ + _)</span>
<span class="fragment" data-fragment-index="2">// error: missing parameter type for expanded function
//        ((x$1: <error>, x$2: Int) => x$1.$plus(x$2))</span>
<span class="fragment" data-fragment-index="3">List(1, 2, 3).myFoldLeft1(0, (a: Int, x: Int) => a + x)
List(1, 2, 3).myFoldLeft1[Int](0, _ + _)
</span>
</span>
</pre></code>

    <aside class="notes">
        <ul>
            <li>As beginner, implement all the functions</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala">xs.foldRight(List.empty)(_ :: _)
<span class="fragment" data-fragment-index="1">// res0: List[Any](1, 2, 3)</span>

<span class="fragment" data-fragment-index="2">def foo: List[Int] = xs.foldRight(List.empty)(_ :: _)</span>
    </code></pre>
    <span class="fragment" data-fragment-index="2">ü§ó</span>

    <aside class="notes">
        <ul>
            <li>Type bounds, scalac infers Nothing - Dotty chooses different bound.</li>
            <li>Unconstrained in this case => Any</li>
            <li>With expected type, you get the correct behaviour</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala">trait Foo[A] { type B }

def foo[A](t: A)
          (implicit f: Foo[A], m: Monoid[f.B]): f.B = m.zero
</pre></code>
</section>

<section>
    <h2>A Note on Contraviariance</h2>
    <pre><code class="scala">trait Show[<span class="fragment">-</span>T] {
  def apply(t: T): String
}</code></pre>
</section>

<section>
    <pre><code class="scala">trait Show[-T] {
  def apply(t: T): String
}

class A
class B extends A
class C extends B

implicit val showAny = new Show[Any] { def apply(any: Any) = "showing Any" }
implicit val showA   = new Show[A]   { def apply(a: A)     = "showing A" }
implicit val showB   = new Show[B]   { def apply(b: B)     = "showing B" }
implicit val showC   = new Show[C]   { def apply(c: C)     = "showing C" }

implicitly[Show[C]].apply(new C) <span class="fragment">// res: "showing Any"</span>
</code></pre>
</section>

<section>
    <pre><code class="scala">trait Show[-T] {
  def apply(t: T): String
}

class A
class B extends A
class C extends B

implicit val showAny: Show[Any] = new { def apply(any: Any) = "showing Any" }
implicit val showA:   Show[A]   = new { def apply(a: A)     = "showing A" }
implicit val showB:   Show[B]   = new { def apply(b: B)     = "showing B" }
implicit val showC:   Show[C]   = new { def apply(c: C)     = "showing C" }

implicitly[Show[C]].apply(new C) <span class="fragment">// res: "showing C"</span>
</code></pre>
</section>

<section>
    <h2>State of Dotty</h2>
    <ul style="list-style-type:none;">
        <li class="fragment"><h3>Already feels very stable</h3></li>
        <li class="fragment"><h3>0.X-releases</h3></li>
        <li class="fragment"><h3>Macro system coming soon‚Ñ¢</h3></li>
        <li class="fragment">
            <h3>Try it out!</h3>
            <pre><code class="bash">$ sbt new lampepfl/dotty.g8

$ brew install lampepfl/brew/dotty</code></pre>
    </ul>
</section>


<section>
    <h1>Thank you!</h1>
</section>
