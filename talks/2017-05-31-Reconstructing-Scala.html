---
title: Reconstructing Scala
venue: Scala Days
summary: >
  The new Scala compiler is nearing beta readiness. A lot of thought has gone
  into designing Dotty to be as fast and structurally sound as possible. Now
  comes the next step - adding a new level of usability to the compiler and the
  surrounding tools.  In this talk I want to show what Dotty can offer you as a
  developer in terms of improved experience - whether it is awesome error
  messages, rewrite rules or optimizations.  I will also talk about how we are
  optimizing the project for outside contributors, and what you can do to get
  involved today!
published: true
video_url: https://www.youtube.com/watch?v=jZzYkga9P9E
date: 2017-05-31
---

<section>
    <h1>RECONSTRUCTING SCALA</h1>
    <p class="white">Felix Mulder</p>
    <p><img id="epfl-logo" src="/assets/talks/reconstructing-scala/Logo_EPFL-white.svg"></p>
</section>

<section>
    Slides: <a href="http://felixmulder.com">felixmulder.com</a>
</section>

<section>
    <h1>Interrupt me, guyz, plz</h1>
</section>

<section>
    <h2>LET'S TAKE A TRIP DOWN MEMORY LANE</h2>
</section>

<section style="text-align: left; font-size: 25px;">
    "We'd like to announce availability of the first implementation of the
    Scala programming language. Scala smoothly integrates object-oriented
    and functional programming. It is designed to express common
    programming patterns in a concise, elegant, and type-safe way. Scala
    introduces several innovative language constructs. For instance:
    <ul style="padding: 20px">
        <li>
            Abstract types and mixin composition unify ideas from object
            and module systsems.
        </li>
        <li>
            Pattern matching over class hierarchies unifies functional and
            object-oriented data access. It greatly simplifies the
            processing of XML trees.
        </li>
        <li>
            A flexible syntax and type system enables the construction of
            advanced libraries and new domain specific languages.
        </li>
    </ul>

    At the same time, Scala is compatible with Java. Java libraries and
    frameworks can be used without glue code or additional declarations.

    The current implementation of Scala runs on Java VM. It requires JDK
    1.4 and can run on Windows, MacOS, Linux, Solaris, and most other
    operating systems. A .net version of Scala is currently under
    development."
    <p>
        <i>- 2004-01-20 by Martin Odersky</i>
    </p>
</section>

<section>
    <h2>Scala 1.x</h2>
    <ul>
        <li>Algebraic Data Types</li>
        <li>Function Values</li>
        <li>Generics</li>
        <li>
            By-name Parameters
            <pre><code class="scala">def foo(i: => Int): Int = {
  if (true) 0
  else i
}</code></pre>
        </li>
    </ul>
</section>
<section>
    <h2>Scala 1.x</h2>
    <ul>
        <li>
            Parameterless methods
            <pre><code class="scala">def length: Int = ???</code></pre>
        </li>

        <li>
            Always eta-expanded partially applied functions:
            <pre><code class="scala">def map(f: Int => Int)(xs: Iterable[Int]) = ???
val square = map(x => x * x)</code></pre>
    </ul>
</section>

<section>
    <h2>Scala 1.x</h2>
    <ul>
        <li>
            Surprising behaviour:
            <pre><code class="scala">println("wat".length)
<span class="fragment">// res: &lt;function&gt;</code></pre>
        </li>
    </ul>
</section>

<section>
    <h3>Scala 2.0 - alias puberty,</h3>
    <h3>or</h3>
    <h3>"a time where cake didn't make them fat"</h3>
</section>

<section>
    <h3>Scala 2.0</h3>
    <ul>
        <li>Auto-add <code>()</code> if reference is to a nullary function</li>
        <li>
            Eta-expand iff:
            <ul>
                <li>Expected type is a function</li>
                <li>
                    Missing parameters are specified with "<code>_</code>"
                    <pre><code class="scala">val square = map(x => x * x)(_)</code></pre>
                </li>
            </ul>
        </li>
        <li>New keywords: <code>implicit, match, requires</code> </li>
        <li>Private qualifiers: <code>private[X]</code>
        <li>Implicit parameters</li>
    </ul>
</section>

<section>
    <h2>Scala 2.1</h2>
    <ul>
        <li>Multi-line strings</li>
        <li>Class literals: <code>classOf[X]</code></li>
        <li>Protected qualifiers: <code>protected[X]</code></li>
    </ul>
</section>

<section>
    <h2>Scala 2.3</h2>
    <ul>
        <li>Procedure syntax</li>
        <li>Tuples</li>
        <li>Extractors using: <code>unapply</code></li>
        <li>Current syntax for self-types introduced</li>
        <li>Case classes cannot be abstract - uh, oh Martin!</li>
    </ul>
</section>

<section>
    <h2>Scala 2.4-2.5</h2>
    <ul>
        <li><code>private[this]</code></li>
        <li>
            Early initialization
            <pre><code class="scala">trait T { val x: Int; println(x) }
class C extends { val x = 5 } with T

new C // res: 5</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>Scala 2.6 - Sturm und Drang</h2>
    <ul>
        <li>Existential Types</li>
        <li>Lazy Values</li>
        <li>Structural Types</li>
        <li>Higher-kinded types?</li>
    </ul>
</section>

<section>
    <h2>Scala 2.7 - revenge of the case class</h2>
    <ul>
        <li>Case classes may now be abstract again - hooray Martin!</li>
        <li>Case classes get extractor methods by default</li>
        <li>Case classes allowed to have companions</li>
        <li>Mixing Scala and Java code in the same project is now allowed</li>
    </ul>
</section>

<section>
    <h2>Scala 2.8 - end of puberty</h2>
    <ul>
        <li>Redesigned Collections</li>
        <li>Specialization using: <code>@specialized</code></li>
        <li>Named and default arguments</li>
        <li>Package objects</li>
    </ul>
</section>

<section>
    <h2>Scala 2.9 - beefing up</h2>
    <ul>
        <li>Parallel collections</li>
        <li>DelayedInit</li>
        <li>App</li>
    </ul>
</section>

<section>
    <h2>Scala 2.10 - the end of adolescence</h2>
    <ul>
        <li>Value Classes</li>
        <li>Implicit Classes</li>
        <li>String Interpolation</li>
        <li>Dependent Method Types</li>
        <li>Scala Reflection</li>
        <li>Macros</li>
    </ul>
</section>

<section>
    <h1>Scala as it is Today</h1>
</section>

<section>
    <h2>Common theme up until 2.10</h2>
    <ul>
        <li>Growth, experimentation, maturing features</li>
        <li>Nearly nothing removed - lost features replaced</li>
        <li>Future 2.X versions - more stability-oriented</li>
    </ul>
</section>

<section>
    <h2>Why the rapid growth?</h2>
    <ul>
        <li>
            <p>Adoption</p>
            <p>- people asked for features</p>
        </li>
        <li>
            <p>It was developed at a University</p>
            <p>- PhD students wanted to see their work applied</p>
        </li>
    </ul>
</section>

<section>
    <h2>Reconstructing Scala</h2>
</section>

<section>
    <h2>Lessons learned in 2.10-2.1X</h2>
    <h2 class="fragment">Spirit of 2.0-2.9</h2>
</section>

<section>
    <h1>Dotty</h1>
</section>

<section>
    <ul>
        <li>Simplification</li>
        <li>Developer Usability</li>
        <li>Correctness - proven foundation, "DOT"</li>
        <li class="fragment">Scala 3</li>
    </ul>
</section>

<section>
    <img style="height: 90%; width: auto;" class="border" src="/assets/talks/reconstructing-scala/contribs.png">
</section>

<section>
    <h2>ERRGONOMICS</h2>
    <ul>
        <li>Awesome Error Messages</li>
        <li>Dottydoc Compiler</li>
    </ul>
</section>

<section>
    <h3>Getting Started with Dotty</h3>
    <ul style="list-style-type:none;">
        <li class="fragment" style="text-align: center;">
            <a target="_blank" href="https://scastie.scala-lang.org/?target=dotty">
                Scastie
            </a>
        </li>
        <li class="fragment">
            <pre><code class="scala">$ brew install lampepfl/brew/dotty</code></pre>
        </li>
        <li class="fragment">
            <pre><code class="scala">$ sbt new lampepfl/dotty.g8</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>Let's try some things out</h2>
    <ul>
        <li>Brew</li>
        <li>IDE</li>
        <li>Dottydoc</li>
    </ul>
</section>

<section>
    <h3>Awesome Error Messages</h3>
    <div class="fragment">
        <div style="float: left; width: 50%; height: 100%;">
            <ul>
                <li><a href="https://github.com/ALPHA-60">@ALPHA-60</a></li>
                <li><a href="https://github.com/AndrewZurn">@AndrewZurn</a></li>
                <li><a href="https://github.com/ShaneDelmore">@ShaneDelmore</a></li>
                <li><a href="https://github.com/abeln">@abeln</a></li>
                <li><a href="https://github.com/adamtrousdale">@adamtrousdale</a></li>
                <li><a href="https://github.com/b-studios">@b-studios</a></li>
                <li><a href="https://github.com/ennru">@ennru</a></li>
                <li><a href="https://github.com/hhandoko">@hhandoko</a></li>
                <li><a href="https://github.com/jarrodj">@jarrodj</a></li>
            </ul>
        </div>
        <div style="float: left; width: 50%; height: 100%;">
            <ul>
                <li><a href="https://github.com/jozi-k">@jozi-k</a></li>
                <li><a href="https://github.com/jyotman94">@jyotman94</a></li>
                <li><a href="https://github.com/ljdelight">@ljdelight</a></li>
                <li><a href="https://github.com/m-sp">@m-sp</a></li>
                <li><a href="https://github.com/markusthoemmes">@markusthoemmes</a></li>
                <li><a href="https://github.com/maseev">@maseev</a></li>
                <li><a href="https://github.com/rubenpieters">@rubenpieters</a></li>
                <li><a href="https://github.com/sebastianharko">@sebastianharko</a></li>
                <li><a href="https://github.com/thiagoandrade6">@thiagoandrade6</a></li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h2>Let's try some things out</h2>
    <ul>
        <li>Brew</li>
        <li>IDE</li>
        <li>Dottydoc</li>
    </ul>
</section>

<section>
    <h3>Key Differences</h3>
    <ul>
        <li><a href="https://contributors.scala-lang.org/t/implicits-with-inferred-return-type-lead-to-undefined-behavior/615">Explicit Implicits</a></li>
        <li>No more procedure syntax</li>
        <li>Union Types</li>
        <li>Intersection Types</li>
        <li>Trait Parameters</li>
        <li>Implicit Functions</li>
        <li>Enums</li>
        <li>Callgraph, automatic specialization</li>
        <li>Library defined rewrites</li>
        <li>TASTY</li>
        <li>IDE using Visual Studio Code</li>
    </ul>
</section>

<section>
    <h3>TYPE INFERENCE</h3>
    <a href="https://www.youtube.com/watch?v=YIQjfCKDR5A">Dotty and Types: The Story So Far</a>
    <h4 style="margin-top: 20px">by Guillaume Martres</h4>
</section>

<section>
    <pre><code class="scala">trait List[+A] {
  def foldRight[B](z: B)(f: (A, B) => B): B = ???
}

List(1, 2, 3).foldRight(List.empty)(_ :: _) <mark class="red fragment">// scalac: nope </mark>
                                            <mark class="green fragment">//  dotty:  yep </mark>
</code></pre>
</section>

<section>
    <h1>Implicit Functions</h1>
</section>

<section>
    <code class="scala">implicit A => B</code>
</section>

<section>
    <h2 class="fragment">Tagless Final Interpreters</h2>
</section>

<section>
    <pre><code class="scala">sealed trait Exp[T]
final case class Add[T](t1: T, t2: T) extends Exp[T]
final case class Lit[T](i: Int) extends Exp[T]</code></pre>

<pre class="fragment" data-fragment-index="2"><code class="scala">implicit val evalInt: Eval[Int] = new Eval[Int] {
  def apply(exp: Exp[Int])): Int = exp match {
    case Add(t1, t2) => apply(t1) + apply(t2)
    case Lit(const)  => const
  }
}</code></pre>

<pre class="fragment" data-fragment-index="1"><code class="scala">// 8 + (2 + 2 + 2)
def expr1[T](implicit eval: Eval[T]): T =
  eval(Add(Lit(8), Add(Lit(2), Add(Lit(2), Lit(2)))))</code></pre>
</section>

<section>
    <h2>What if we want multiplication?</h2>
</section>

<section>
    <pre><code class="scala">sealed trait Exp[T]
final case class Add[T](t1: T, t2: T) extends Exp[T]
<mark class="green">final case class Mul[T](i: Int) extends Exp[T]</mark>
final case class Lit[T](i: Int) extends Exp[T]</code></pre>

<pre><code class="scala">implicit val evalInt: Eval[Int] = new Eval[Int] {
  def apply(exp: Exp[Int])): Int = exp match {
    case Add(t1, t2) => apply(t1) + apply(t2)
    <mark class="green">case Mul(t1, t2) => apply(t1) * apply(t2)</mark>
    case Lit(const)  => const
  }
}</code></pre>

<pre><code class="scala">// 8 + (2 + 2 + 2)
def expr1[T](implicit eval: Eval[T]): T =
  eval(Add(Lit(8), Add(Lit(2), Add(Lit(2), Lit(2)))))

<mark class="green">def expr2[T](implicit eval: Eval[T]): T =
  eval(Add(Lit(8), Mul(Lit(2), Lit(3))))</mark></code></pre>
</section>

<section>
    <pre><code class="scala">trait Exp[T] {
  def add(t1: T, t2: T): T
  def lit(i: Int) = T
}

implicit val intExp: Exp[Int] = new Exp[Int] {
  def add(t1: Int, t2: Int) = t1 + t2
  def lit(i: Int) = i
}

// 8 + (2 + 2 + 2)
def expr1[T](implicit e: Exp[T]) =
  e.add(e.lit(8), e.add(e.lit(2), e.add(e.lit(2), e.lit(2))))
</code></pre>
</section>

<section>
    <pre><code class="scala">object ExpSyntax {
  def lit[T](i: Int)(implicit e: Exp[T]): T = e.lit(i)
  def add[T](l: T, r: T)(implicit e: Exp[T]): T = e.add(l, r)
}
import ExpSyntax._
</code></pre>
</section>

<section>
    <pre><code class="scala">trait Exp[T] {
  def add(t1: T, t2: T): T
  def lit(i: Int) = T
}

implicit val intExp: Exp[Int] = new Exp[Int] {
  def add(t1: Int, t2: Int) = t1 + t2
  def lit(i: Int) = i
}

// 8 + (2 + 2 + 2)
def expr1[T: Exp] =
  add(lit(8), add(lit(2), add(lit(2), lit(2))))
</code></pre>
</section>

<section>
    <pre><code class="scala">trait Mul[T] {
  def mul(t1: T, t2: T): T
}

implicit val intMul: Mul[Int] = new Mul[Int] {
  def mul(i1: Int, i2: Int) = i1 * i2
}

// 8 + 3 * 2
def expr2[T : Exp : Mul] =
  add(lit(8), mul(lit(3), lit(2)))
</code></pre>
</section>

<section>
    <pre><code class="scala">type Ring[T] = implicit (Exp[T], Mul[T]) => T

// 8 + 3 * 2
def expr2: Ring[T] =
  add(lit(8), mul(lit(3), lit(2)))</code></pre>
    <a href="https://gist.github.com/OlivierBlanvillain/48bb5c66dbb0557da50465809564ee80">Revisiting Tagless Final Interpreters</a> - Olivier Blanvillain
</section>


<section style="text-align: left;">
    <div style="float: left; width: 50%; height: 100%;">
        <h2 style="margin-bottom: 0; margin-top: 0.5em;">REPL</h2>
        <a target="_blank" href="https://github.com/lampepfl/dotty/issues?q=is%3Aopen+is%3Aissue+label%3Aarea%3Arepl">Issues</a>
        <h2 style="margin-bottom: 0; margin-top: 0.5em;">ERROR MESSAGES</h2>
        <a target="_blank" href="http://github.com/lampepfl/dotty/issues/1589">Issue #1589</a>
    </div>
    <div style="float: left; width: 50%; height: 100%;">
        <h2 style="margin-bottom: 0; margin-top: 0.5em; text-transform: none;">IDEs &amp; TOOLING</h2>
        <a target="_blank" href="https://github.com/lampepfl/dotty/labels/area%3Atooling">Issues</a>
        <h2 style="margin-bottom: 0; margin-top: 0.5em; text-transform: none;">Build Tools</h2>
    </div>
</section>

<section>
    <h2>Answers</h2>
    <ul>
        <li>Why 0.1.2-RC1? Because reasons</li>
        <li>I have a suggestion! TTYL &lt;3</li>
        <li>Macros? Soon! Via scalamacros and scalameta</li>
        <li>SI-2712? Yes</li>
        <li>Next release? Six weeks!</li>
    </ul>
</section>

<section>
    <h1>Question?</h1>
</section>

<section>
    <h1>Thank you!</h1>
</section>
